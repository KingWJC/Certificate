# 设计模式

关注软件系统的设计，与具体的实现语言无关。

## 分类

1. 创建型：主要描述如何创建对象，主要特点是“将对象的创建与使用分离”，为设计类实例化新对象提供指南。

   | 名称                         | 说明                                                         | 关键点         |
   | ---------------------------- | ------------------------------------------------------------ | -------------- |
   | 工厂方法（Factory）          | 定义一个创建对象的接口，由子类决定需要实例化哪一个类，子类实例化的过程推迟。 | 动态生产对象   |
   | 抽象工厂（Abstract Factory） | 定义一个创建一系列相关或相互依赖的对象的接口，直接指定工厂，而无需指定具体的类 | 生产成系列对象 |
   | 原型（Prototype）            | 通过拷贝原型实例来创建新对象                                 | 克隆对象       |
   | 单例（Singleton）            | 保证一个类只有一个实例，并提供全局访问点                     | 单实例         |
   | 构建器（Builder）            | 将一个复杂类的表示和其构造分离，使相同的构建过程能得到不同的表示 | 复杂对象构建   |

2. 结构型：主要用于处理类或对象的组合，描述如何将类或对象按某种布局形成更大的结构。

   | 名称              | 说明                                                         | 关键点       |
   | ----------------- | ------------------------------------------------------------ | ------------ |
   | 适配器（Adapter） | 使原本不相容的接口得以协同工作                               | 转换接口     |
   | 桥接（Bridge）    | 将类的抽象部分和实现部分分离开来，各自独立的变化             | 继承树拆分   |
   | 组合（Composite） | 将对象组合成树型结构表示”整体-部分“的层次结构，对当个对象和组合对象的使用具有一致性 | 树形结构     |
   | 装饰（Decorator） | 动态给对象添加额外的职责，替换用子类（继承）来扩展功能，更灵活 | 动态附加职责 |
   | 外观（Facade）    | 定义高层接口，为系统中一组接口提供一个一致的外观，简化使用   | 对外统一接口 |
   | 享元（Flyweight） | 支持大量细粒度对象的共享                                     | 汉字编码     |
   | 代理（Proxy）     | 使用一个代理来控制一个对象的访问                             | 快捷方式     |

3. 行为型：主要用于描述类或对象之间怎样相互协作共同完成单个对象无法单独完成的任务，以及职责的分配，对类之间交互以及分配责任的方式提供指南。

   | 名称                             | 说明                                                         | 关键点           |
   | -------------------------------- | ------------------------------------------------------------ | ---------------- |
   | 责任链（Chain of Responsibility) | 将接受对象链接起来，在链中传递请求，直到有一个对象处理这个请求，减少请求的发送者和接收者之间的耦合。 | 传递职责         |
   | 命令（Command）                  | 将请求封装成一个命令对象，可用不同请求对客户进行参数化。     | 日志记录，可撤销 |
   | 解释器（Interpreter）            | 根据文法表示来解释语言中的句子                               | 虚拟机机制       |
   | 迭代器（Iterator）               | 提供顺序访问一个聚合对象中的元素，且不需要暴露对象的内部表示 | 数据集           |
   | 中介者（Mediator）               | 用中介对象封装一系列的对象交互。使各对象不需要显示的相互调用，达到低耦合，且可以独立改变对象间的i交互 | 不直接引用       |
   | 备忘录（Memento）                | 在不破坏封装的前提下，保存一个对象的内部状态，并可以在以后将该对象恢复到原先保存的状态 | 游戏存档         |
   | 观察者（Observer）               | 定义对象间一对多的关系，当一个对象的状态发生变化，所有依赖于它的对象都得到通知并自动更新 | 联动             |
   | 状态（State）                    | 允许一个对象在其内部状态改变时，改变它的行为                 | 封装状态         |
   | 策略（Strategy）                 | 定义并封装一系列算法，可以互相替换，从而让算法独立于使用它的用户而变化 | 多方案切换       |
   | 模板方法（Template Method)       | 定义一个操作中的算法骨架，将一些步骤延迟到子类中，使子类可以不改变算法结构，即可重新定义算法的某些步骤 | 框架             |
   | 访问者（Visitor）                | 表示一个作用于某对象结构中的各元素的操作，使得在不改变各元素的前提下定义作用于这些元素的新操作 | 数据与操作分离   |

根据作用范围，分为类模式和对象模式

1. **类模式**用于处理类与子类之间的关系，这些关系通过继承来建立，是静态的，在编译时刻便确定下来了

2. **对象模式**用于处理对象之间的关系，这些关系可以通过组合或聚合来实现，在运行时刻是可以变化的，更具动 态性。

   **工厂方法，（类）适配器，解释器，模板方法**既可以是类模式，也可以是对象模式；其它都是对象模式。

## 描述

1. 设计模式（Design Pattern）是前辈们对代码开发经验的总结，是解决特定问题的 一系列套路。它不是语法规定，而是一套用来提高代码可复用性、可维护性、可读性、 稳健性以及安全性的解决方案。
2. 由于传统的结构化的软件设计方法不符合面向对象的设计原则，无法很好的实现高内聚和低耦合的要求。模块之间过于紧密，给软件扩展和维护带来很多困难。在这种情况下，设计模式的出现和广泛应用给问题的解决提供了一种有效方法。通过利用设计模式，可以帮助开发者复用已有的设计方法，设计出结构合理、易于复用和可维护的软件,当用户需要发生改变时，可以通过修改少量代码或不修改原有代码即可满足新的需求，增强了系统的可修改性和稳定性，降低系统开发成本，对优化软件结构，提高软件质量具有重要的指导意义。
3. 一般而言，一个设计模式具有模式名称和定义、适应场景、解决方案和效果四个方面的基本要素。
4. 以上设计模式的选用基本达到了预期的效果。首先是，这些设计模式都是一些常用的设计方法，在架构设计师、系统分析师、开发人员之间，形成了良好的沟通桥梁，大家很容易进行交流和沟通。其次，在使用设计模式过程中，软件的开发效率较高，能够节省开发成本。最重要的是，这些模式都是一些经过反复使用的成熟设计方案，符合面向对象中设计规范，比如:面向接口编程、里氏替换原则、单一职责原则、依赖倒转等设计原则，最大限度的提高软件的标准化，为日后的系统维护打下了很好的基础

## 应用

1. **抽象工厂**

   1. 定义：为创建一组相关或者相互依赖的对象提供一个接口，而不需要指定它们的具体类

   2. 实现过程：对工厂模式又进行了一层抽象，不单单是像工厂模式只生成一类产品，而是一系列产品，并且可以像零件一样灵活配置给各工厂。（产品族：两个相互影响的产品线。)

   3. 应用场景：一组对象有相同的约束。如不同系统下的文本和图片编辑器，==共同的约束条件操作系统类型==

   4. 优点：

      **封装性，分离了具体的类**：Abstract Factory 模式帮助你控制一个应用创建对象的类。因为一个工厂封装创建产品对象的责任和过程，它将客户与类的实现分离。客户通过它们的抽象接口操纵实例。产品的类名也在具体工厂的实现中被分离；它们不出现在客户代码中。

      **使得易于交换产品系列：** 一个具体工厂类在一个应用中仅出现一次—即在它初始化的时候。这使得改变一个应用的具体工厂变得很容易。它只需改变具体的工厂即可使用不同的产品配置，这是因为一个抽象工厂创建了一个完整的产品系列，所以整个产品系列会立刻改变。

      **产品族内的约束为非公开状态，有利于产品的一致性**：当一个系列中的产品对象被设计成一起工作时，一个应用一次只能使用同一个系列中的对象，这一点很重要。而AbstractFactory很容易实现这一点。

   5. 缺点：**难以支持新种类的产品，产品族的扩展困难**。是因为AbstractFactory接口确定了可以被创建的产品集合。 支持新种类的产品就需要扩展该工厂接口，这将涉及 AbstractFactory类及其所有子类的改变。

   6. 项目应用：支持多个数据库、通用的数据库访问层

      对于不同数据库的访问，只有Connection、Command、Adapter、Parameter对象类型不同，而实现逻辑大部分相同，所以**可以针对 Oracle、MySQL、DB2 等分别建立抽象工厂，如指定当前工厂为 Oracle 工厂，则创建出来的数据库连接，数据集等一系列的对象都是符合 Oracle 操作要求的，这样便于数据库之间的切换.。**

      通过使用DbProviderFactory抽象类来生成不同数据库下的Connection和Adapter，将公共的数据库访问逻辑提取出来，组成一个抽象类DBHelper。而每个数据库都有单独的处理类，且都继承DBHelper，可以实现其特有的处理逻辑。 
      
      数据库的切换：使用简单工厂模式和配置文件，将编译期创建对象转化为运行时期创建对象。

2. **责任链模式**

   1. 定义：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将多个对象连成一条链，沿着这条链传递该请求，直到有一个对象处理它为止。
   
   2. 优点;  客户只需要将请求发送到责任链上即可，无须关心请求的处理细节和请求的传递 过程，所以责任链将请求的发送者和请求的处理者解耦了； 具有可扩展性; 灵活性; 责任分担;
   
      请求和处理都包含状态属性，通过状态，让符合条件的处理来接收请求。
   
   3. 缺点：链比较长时, 性能问题, 可控性差，职责多级传递，不知道何处出错。
   
4. 应用：
      1. 事件模型中，如DOM中，从外到内的事件捕捉，从内到外的事件冒泡。
      2. 框架，容器中，如Java Servlet的Filter机制。
      3. 异常处理机制：需要分模块分时间分批次完成，不同抽象层次的对象处理不同层次的异常，通过包装提升异常的抽象层次，交予上级处理。
      
   5. 方法捕捉异常的处理情形：
   
      1. 不在方法规范的职责内，将异常和必要信息以更抽象的形式包装，抛给更高层。
      2. 部分由该方法负责，处理并抛出。
      3. 完全由该方法负责，处理异常，不抛出。
   
   6. 涉及：单一职责原则，间接原则，保变原则，迪米特法则。
   
   7. 综合应用：责任链关注职责的分解，侧重行为，装饰者关心职责的结合，侧重结构。责任链的每一环为某个对象进行装饰和包装。
   
   8. 项目应用，MVC的架构中，需要对某些接口的请求和响应进行校验和处理，比如接口请求日志、JWT校验、参数校验、对外接口签名校验、格式化返回结果、接口权限等。为了，对指定请求增加过滤器，每个请求都要经过一些过滤器组成的责任链，进行校验和处理。按照由高到低的顺序，依次进行处理，直到符台某个标准为止，并完成信息处理，将对象信息按照审核的分档标准，存入信息库。通过这个方法，可以实现农产品对象，与处理方法的分离。
   
3. **代理模式**

   1. 定义：对其它对象提供一种代理，用来控制对这个对象的访问。
   2. 特点：保持对象的接口（代理对象和对象的接口相同），限制接口的服务（代理对象中增加业务逻辑）
   3. 优点：
      1. 职责清晰（具体主题不用关心非本职的事务，代理类可以扩展其它功能），
      2. 高扩展性(具体主题的变化，不会影响代理类）。
   4. 实现：

      1. 普通代理(给代理对象指定真实对象,不允许直接创建真实角色)，
      2. 强制代理(真实对象指定代理对象,不允许直接访问真实角色)，
      3. 动态代理(反射动态生成，被代理类必须实现一个接口；实现横切面编程，在不改变代码的前提下，增强或控制对象的行为).
   5. 应用，某些重要业务中，进行增删改数据后，需要写数据操作日志；进行增改前，需要检测数据是否重复。为了保证在不修改已有代码的前提下，完成这个需求，采用动态代理模式来实现。它的本质是创造一个实现了同一个接口的Proxy代理类，去进行真正的调用。先设计一个接口，包含两个方法：执行前和执行后；以及继承这个接口的两个类：数据操作日志和数据重复检测。在动态代理模式中，会使用接口和类型反射生成代理对象，代理对象可以用接口接收，最后用代理对象来执行业务中的增删改方法。好处是不仅对增删改方法做了增强，而且不会影响代理类，也提高了代码的复用，以及灵活性。

4. 策略模式 

   1. 定义: 该模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算 法的变化不会影响使用算法的客户。 
   2. 优点: 多重条件语句不易维护，而使用策略模式可以避免使用多重条件语句。 
   3. 例子: 坐标系的转换, 高德/ 百度/ 标准 wgs84 , 如原始空间数据的坐标系为高德坐标, 需要转换为其它坐标系, 定义一个抽象策略类和两个具体策略类, 具体策略类 A—标准转高 德, 具体策略类 B—标准转百度, 还有一个环境类, 持有一个策略类的引用, 最终给客户端调用。

# 设计原则

- 单一设计原则：设计目的功能单一的类
- 里氏替换原则：子类可以替换父类
- 依赖倒置原则：依赖抽象，而不依赖具体实现；针对接口编程，而不是针对实现编程。
- 接口隔离原则：使用多个专门的接口比使用一个总接口要好
- 迪米特法则：最少知识法则，一个对象应当对其它对象尽可能的减少了解。
- 开闭原则：对扩展开放，对修改关闭。
- 组合重用原则：尽量使用组合，而不是继承关系达到重用目的